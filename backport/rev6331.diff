Index: rtc_lld.c
===================================================================
--- rtc_lld.c	(revision 6330)
+++ rtc_lld.c	(revision 6331)
@@ -187,6 +187,7 @@
       rtcp->id_rtc->CR &= ~RTC_CR_ALRAE;
     }
   }
+#if RTC_ALARMS == 2
   else{
     if (alarmspec != NULL){
       rtcp->id_rtc->CR &= ~RTC_CR_ALRBE;
@@ -201,6 +202,7 @@
       rtcp->id_rtc->CR &= ~RTC_CR_ALRBE;
     }
   }
+#endif /* RTC_ALARMS == 2 */
 }
 
 /**
@@ -217,8 +219,10 @@
                        RTCAlarm *alarmspec) {
   if (alarm == 1)
     alarmspec->tv_datetime = rtcp->id_rtc->ALRMAR;
+#if RTC_ALARMS == 2
   else
     alarmspec->tv_datetime = rtcp->id_rtc->ALRMBR;
+#endif
 }
 
 /**
@@ -231,6 +235,7 @@
  *
  * @api
  */
+#if RTC_HAS_PERIODIC_WAKEUPS
 void rtcSetPeriodicWakeup_v2(RTCDriver *rtcp, RTCWakeup *wakeupspec){
   chDbgCheck((wakeupspec->wakeup != 0x30000),
               "rtc_lld_set_periodic_wakeup, forbidden combination");
@@ -249,6 +254,7 @@
     rtcp->id_rtc->CR &= ~RTC_CR_WUTE;
   }
 }
+#endif /* RTC_HAS_PERIODIC_WAKEUPS */
 
 /**
  * @brief     Gets time of periodic wakeup.
@@ -260,11 +266,13 @@
  *
  * @api
  */
+#if RTC_HAS_PERIODIC_WAKEUPS
 void rtcGetPeriodicWakeup_v2(RTCDriver *rtcp, RTCWakeup *wakeupspec){
   wakeupspec->wakeup  = 0;
   wakeupspec->wakeup |= rtcp->id_rtc->WUTR;
   wakeupspec->wakeup |= (((uint32_t)rtcp->id_rtc->CR) & 0x7) << 16;
 }
+#endif /* RTC_HAS_PERIODIC_WAKEUPS */
 
 /**
  * @brief   Get current time in format suitable for usage in FatFS.
Index: rtc_lld.h
===================================================================
--- rtc_lld.h	(revision 6330)
+++ rtc_lld.h	(revision 6331)
@@ -36,11 +36,24 @@
 /*===========================================================================*/
 
 /**
- * @brief   Two alarm comparators available on STM32F4x.
+ * @brief   Two alarm comparators available on STM32F4x and STM32F2x.
  */
-#define RTC_ALARMS                  2
+#if !defined(STM32F0XX)
+#define RTC_ALARMS                2
+#else
+#define RTC_ALARMS                1
+#endif
 
 /**
+ * @brief   STM32F0x has no periodic wakeups.
+ */
+#if !defined(STM32F0XX)
+#define RTC_HAS_PERIODIC_WAKEUPS  TRUE
+#else
+#define RTC_HAS_PERIODIC_WAKEUPS  FALSE
+#endif
+
+/**
  * @brief   Data offsets in RTC date and time registers.
  */
 #define RTC_TR_PM_OFFSET    22
@@ -81,9 +94,11 @@
 #define RTC_USE_INTERRUPTS                FALSE
 #endif
 
+#if defined(STM32_PCLK1) /* For devices without STM32_PCLK1 (STM32F0xx) */
 #if STM32_PCLK1 < (STM32_RTCCLK * 7)
 #error "STM32_PCLK1 frequency is too low to handle RTC without ugly workaround"
 #endif
+#endif /* defined(STM32_PCLK1) */
 
 /*===========================================================================*/
 /* Driver data structures and types.                                         */
@@ -144,6 +159,7 @@
   uint32_t tv_datetime;
 };
 
+#if RTC_HAS_PERIODIC_WAKEUPS
 /**
  * @brief   Structure representing an RTC periodic wakeup period.
  */
@@ -157,6 +173,7 @@
    */
   uint32_t wakeup;
 };
+#endif /* RTC_HAS_PERIODIC_WAKEUPS */
 
 /**
  * @brief   Structure representing an RTC driver.
@@ -192,8 +209,10 @@
   void rtc_lld_get_alarm(RTCDriver *rtcp,
                          rtcalarm_t alarm,
                          RTCAlarm *alarmspec);
+#if RTC_HAS_PERIODIC_WAKEUPS
   void rtcSetPeriodicWakeup_v2(RTCDriver *rtcp, RTCWakeup *wakeupspec);
   void rtcGetPeriodicWakeup_v2(RTCDriver *rtcp, RTCWakeup *wakeupspec);
+#endif /* RTC_HAS_PERIODIC_WAKEUPS */
   uint32_t rtc_lld_get_time_fat(RTCDriver *rtcp);
 #ifdef __cplusplus
 }
